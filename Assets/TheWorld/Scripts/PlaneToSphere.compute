
float2 SphereToUV(float3 input)
{
    input = normalize(input);

    float lat = asin(input.y);
    float long = atan2(input.x, -input.z);
    
    const float PI = 3.141594;
    float u = (long / PI + 1) * 0.5;
    float v = lat / PI + 0.5;

    return float2(clamp(u, 0, 1), v);
}

float3 UVToSphere(float2 uv)
{
    uv = float2(clamp(uv.x, 0, 1), clamp(uv.y, 0, 1));

    const float PI = 3.14159265359;
    float long = (uv.x / 0.5 - 1) * PI;
    float lat = (uv.y - 0.5) * PI;

    float y = sin(lat);
    float r = cos(lat);
    float x = sin(long) * r;
    float z = -cos(long) * r;
    return float3(x, y, z);
}

#pragma kernel TextureToSphere

StructuredBuffer<float3> readPoints;
RWStructuredBuffer<float4> colors;
Texture2D<float4> ColorMap;
SamplerState samplerColorMap;


[numthreads(16,1,1)]
void TextureToSphere(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV((readPoints[id.x]));
    float4 depth = ColorMap.SampleLevel(samplerColorMap, float2(uv.x, uv.y), 0);
    colors[id.x] = float4(depth);
}

#pragma kernel SphereToPlane

RWStructuredBuffer<float3> flatPoints;

[numthreads(16, 1, 1)]
void SphereToPlane(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV(flatPoints[id.x]);
    flatPoints[id.x] = float3(uv.x * 2.0, uv.y, 0);
}

#pragma kernel PlaneToSphere

RWStructuredBuffer<float3> psPoints;

[numthreads(16, 1, 1)]
void PlaneToSphere(uint3 id : SV_DispatchThreadID)
{
    psPoints[id.x] = UVToSphere(float2(psPoints[id.x].x * 0.5, psPoints[id.x].y));
}

