
float2 SphereToUV(float3 input, float yOffset)
{
    input = normalize(input);

    float lat = asin(input.y);
    float long = atan2(input.x, -input.z);
    
    const float PI = 3.141593;
    float u = (long / PI + 1) * 0.5;
    float v = lat / PI + 0.5;

    return float2(clamp(u, 0, 1), v);
}

float3 UVToSphere(float2 uv)
{
    uv = float2(clamp(uv.x, 0, 1), clamp(uv.y, 0, 1));

    const float PI = 3.141593;
    float long = (uv.x / 0.5 - 1) * PI;
    float lat = (uv.y - 0.5) * PI;

    float y = sin(lat);
    float r = cos(lat);
    float x = sin(long) * r;
    float z = -cos(long) * r;
    return float3(x, y, z);
}

#pragma kernel TextureToSphere

StructuredBuffer<float3> readPoints;
RWStructuredBuffer<float4> colors;
Texture2D<float4> ColorMap;
SamplerState samplerColorMap;

[numthreads(1,1,1)]
void TextureToSphere(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV((readPoints[id.x]), 0);
    float4 depth = ColorMap.SampleLevel(samplerColorMap, float2(uv.x, uv.y), 0);
    colors[id.x] = float4(depth);
}

#pragma kernel SphereToPlane

StructuredBuffer<float3> spPoints;
RWStructuredBuffer<float2> uvs;
float xOffset;
float yOffset;

[numthreads(1, 1, 1)]
void SphereToPlane(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV(spPoints[id.x], yOffset);
    uvs[id.x] = float2((uv.x + xOffset) * 2.0, uv.y);
}

#pragma kernel PlaneToSphere

StructuredBuffer<float2> pPoints;
RWStructuredBuffer<float3> sPoints;

[numthreads(1, 1, 1)]
void PlaneToSphere(uint3 id : SV_DispatchThreadID)
{
    sPoints[id.x] = UVToSphere(float2(pPoints[id.x].x * 0.5, pPoints[id.x].y));
}

