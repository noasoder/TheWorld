
float2 SphereToUV(float3 input)
{
    input = normalize(input);

    float lat = asin(input.y);
    float long = atan2(input.x, -input.z);
    
    const float PI = 3.141594;
    float u = (long / PI + 1) * 0.5;
    float v = lat / PI + 0.5;

    return float2(clamp(u, 0, 1), v);
}

float3 UVToSphere(float2 uv)
{
    const float PI = 3.141594;
    float long = (uv.x / 0.5 - 1) * PI;
    float lat = (uv.y - 0.5) * PI;

    float y = sin(lat);
    float r = cos(lat);
    float x = sin(long) * r;
    float z = -cos(long) * r;
    return float3(x, y, z);
}

#pragma kernel TextureToSphere

StructuredBuffer<float3> readPoints;
RWStructuredBuffer<float4> writePoints;
Texture2D<float4> DepthMap;
SamplerState samplerDepthMap;


[numthreads(16,1,1)]
void TextureToSphere(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV((readPoints[id.x].xyz));
    float4 depth = DepthMap.SampleLevel(samplerDepthMap, float2(uv.x, uv.y), 0);
    writePoints[id.x] = float4(depth);
}

#pragma kernel SphereToPlane

RWStructuredBuffer<float3> spPoints;

[numthreads(16, 1, 1)]
void SphereToPlane(uint3 id : SV_DispatchThreadID)
{
    float2 uv = SphereToUV(spPoints[id.x]);
    spPoints[id.x] = float3(uv.x * 2.0, uv.y, 0);
}

#pragma kernel PlaneToSphere

RWStructuredBuffer<float3> psPoints;

[numthreads(16, 1, 1)]
void PlaneToSphere(uint3 id : SV_DispatchThreadID)
{
    psPoints[id.x] = UVToSphere(float2(psPoints[id.x].x * 0.5, psPoints[id.x].y));
}

